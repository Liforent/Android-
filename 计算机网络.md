# 

## 一.问题定位

 1.正式环境配置的app_network_security_config

![img](https://ecnj5070ng8v.feishu.cn/space/api/box/stream/download/asynccode/?code=NDFiNGEyNmU2MjgyYTZmMDI1MWU3YWY5MjJhNGJhODJfYXNWU29pb0p3RzlIazBVTGhlT3hkcU5haUkzMkh3SlJfVG9rZW46WHhrM2JGT0Ixb2tObXV4dkoxdmMxYjFPbmFjXzE3NzIyNTA1MzQ6MTc3MjI1NDEzNF9WNA)

如转包工具（charles，fiddler），安卓手机打开代理，安装对应的证书，则可以在线上抓包。

base-config cleartextTrafficPermitted="true"：设置为true则表示用户可明文流量访问；

<certificates src="system" overridePins="true" />：信任系统证书。

## 二.Charles如何抓包

## 1.使用Charles需要做哪些操作

- 1.电脑上需要安装证书。这个主要是让Charles充当中间人，颁布自己的CA证书。
- 2.手机上需要安装证书。这个是访问Charles获取手机证书，然后安装即可。
- 3.Android项目代码设置兼容。Google 推出更加严格的安全机制，应用默认不信任用户证书（手机里自己安装证书），自己的app可以通过配置解决，相当于信任证书的一种操作！

## 2.可知抓包的突破口集中以下几点

- 第一点：必须链接代理，且跟Charles要具有相同ip。思路：客户端是否可以判断网络是否被代理了。
- 第二点：CA证书，这一块避免使用黑科技hook证书校验代码，或者拥有修改CA证书权限。思路：集中在可以判断是否挂载。
- 第三点：冒充中间人CA证书，在客户端client和服务端server之间篡改拦截数据。思路：可以做CA证书校验。
- 第四点：为了可以在7.0上抓包，App往往配置清单文件networkSecurityConfig。思路：线上环境去掉该配置。

## 三.防抓包实践开发

1 .配置networkSecurityConfig抓包说明

- 中间人代理之所有能够获取到加密密钥就是因为我们手机上安装并信任了其代理证书，这类证书安装后都会被归结到用户证书一类，而不是系统证书。
- 那我们可以选择只信任系统内置的系统证书，而屏蔽掉用户证书（Android7.0以后就默认是只信任系统证书了），就可以防止数据被解密了。

2.实现App防抓包安全配置方式有两种：

- 一种是Android官方提供的网络安全配置；另一种也可以通过设置网络框架实现（以okhttp为例）。
- 第一种：具体可以看清单配置文件，相当于base-config标签下去掉 这组标签。
- 第二种：需要给okhttpClient配置 X509TrustManager 来监听校验服务端证书有效性。遍历设备上信任的证书，通过证书别名将用户证书（别名中含有user字段）过滤掉，只将系统证书添加到验证列表中。

3.该方案优点和缺点分析说明

- 优点：network_security_config配置简单，对整个app网络生效，无需修改代码；代码实现对通过该网络框架请求的生效，能兼容7.0以前系统。
- 缺陷：network_security_config配置方式，7.0以前的系统配置不生效，依然可以通过代理工具进行抓包。okhttp配置的方式只能对使用该网络框架进行数据传输的接口生效，并不能对整个app生效。
- 破解：将手机进行root，然后将代理证书放置到系统证书列表内，就可以绕过代码或配置检查了。

## 四.防抓包方案

##  1.关闭代理

​    

1)charles 和 fiddler 都使用代理来进行抓包，对网络客户端使用无代理模式即可防止抓包，如

```Java
OkHttpClient.Builder()
    .proxy(Proxy.NO_PROXY)
    .build()
```

2)no_proxy实际上就是type属性为direct的一个proxy对象，这个type有三种

  direct，http，socks。这样因为是直连，所以不走代理。所以charles等工具就抓不到包了，这样一定程度上保证了数据的安全，这种方式只是通过代理抓不到包。

3)通常情况下上述的办法有用，但是无法防住使用 VPN 导流进行的抓包

 使用VPN抓包的原理是，先将手机请求导到VPN，再对VPN的网络进行Charles的代理，绕过了对App的代理。

4)该方案优点和缺点分析说明

 优点：实现简单方便，无系统版本兼容问题。

 缺陷：该方案比较粗暴，将一切代理都切断了，对于有合理诉求需要使用网络代理的场景无法满足。

 破解：使用ProxyDroid全局代理工具通过iptables对请求进行强制转发，可以有效绕过代理检测。

 

## 2.证书锁定

   

- 证书锁定是Google官方比较推荐的一种校验方式
  - 原理是在客户端中预先设置好证书信息，握手时与服务端返回的证书进行比较，以确保证书的真实性和有效性。
- 如何实现证书锁定
  - 有两种实现方式：一种通过network_security_config.xml配置，另一种通过代码设置；

```Java
//第一种方式：配置文件
<network-security-config>
    <domain-config>
        <domain includeSubdomains="true">api.zuoyebang.cn</domain>
        <pin-set expiration="2025-01-01">
            <pin digest="SHA-256">38JpactkIAq2Y49orFOOQKurWxmmSFZhBCoQYcRhK90=</pin>
            <!-- 备用证书信息，一般为域名证书的二级证书 -->
            <pin digest="SHA-256">9k1a0LRMXouZHRC8Ei+4PyuldPDcf3UKgO/04cDM90K=</pin>
        </pin-set>
    </domain-config>
</network-security-config>

//第二种方式：代码设置
fun sslPinning(): OkHttpClient {
    val builder = OkHttpClient.Builder()
    val pinners = CertificatePinner.Builder()
        .add("api.zuoyebang.cn", "sha256//89KpactkIAq2Y49orFOOQKurWxmmSFZhBCoQYcRh00L=")
        .add("api.zuoyebang.com", "sha256//a8za0LRMXouZHRC8Ei+4PyuldPDcf3UKgO/04cDM1o=09")
        .build()
    builder.apply {
        certificatePinner(pinners)
    }
    return builder.build()
}
```

- 该方案优点和缺点分析说明
  -  优点：安全性高，配置方式也比较简单，并能实现动态更新配置。

  -  缺陷：网络安全配置无法实现证书证书的动态更新，另外该配置也受Android系统影响，对7.0以前的系统不支持。代码配置相对灵活些。

  -  破解：证书锁定破解比较复杂，比如老牌的JustTrustMe插件，通过hook各网络框架的证书校验方法，替换原有逻辑，使校验失效

# 